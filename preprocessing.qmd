---
title: "preprocessing"
format: html
editor: visual
---



# Install Packages

```{r}

install.packages("pacman")
library("pacman")

p_install("dplyr", force = FALSE)
p_install("ggplot2", force = FALSE)
p_install("readr", force = FALSE)
p_install("tidyr", force = FALSE)
p_install("sf", force = FALSE)
p_install("terra", force = FALSE)
p_install("tmap", force = FALSE)
p_install("zoo", force = FALSE)
p_install("units", force = FALSE)
p_install("plotly", force = FALSE)
p_install("patchwork", force = FALSE)
p_install("tidyverse", force = FALSE)
p_install("rjson", force = FALSE)
p_install("jsonlite", force = FALSE)
p_install("leaflet", force = TRUE)
p_install("shiny", force = TRUE)
p_install("XML", force = TRUE)
p_install("lubridate", force = TRUE)
p_install("ggh4x", force = TRUE)

library("ggh4x")
library("dplyr")
library("ggplot2")
library("tidyr")
library("sf")
library("terra")
library("tmap")
library("zoo")
library("zoo")
library("units")
library("plotly")
library("patchwork")
library("tidyverse")
library("rjson")
library("jsonlite")
library("leaflet")
library("XML")
library("lubridate")
library("shiny")


```


# Task 1: Import your data

Folgend werden alle .gpx-Files aus dem Ordner *GPS_Daten* eingelesen. Aus den .gpx-Files werden die Koordinaten herausgelesen und jede gefahrene Route / Aktivität in einem neuen Dataframe abgespeichert. Die Dataframes landen alle in einer Liste `single_routes` und können über diese abgerufen und dargestellt werden.In einer weiteren Variate werden alle Daten in einen einzigen Data Frame verpackt `all_routes`.

```{r}


# generate a list of all filenames including the path from the subfolder they are stored in
file_list <- list.files("gps_files_shared", recursive = TRUE, pattern = "\\.gpx$", full.names = TRUE)

# Get Path of the subfolders to extraxt names of subfolders and / or filenames
# Credits go to: https://stackoverflow.com/questions/54082781/extract-portion-of-file-name-using-gsub
file_name <- gsub('.*/(.*).gpx','\\1', file_list)

# creating empty vessels for our soon to be imported data using a for loop
single_routes <- list()
all_routes <- data.frame()

# create a for loop to read in every single gpx file in the subfolder and extraxt the needed values such as coordinates, elevation and timestamps
for (file in file_list) {
  
  # Parse the GPX file using the htmlTreeParse() Function
  # Credits go to: https://www.appsilon.com/post/r-gpx-files
  gpx_parsed <- htmlTreeParse(file = file, useInternalNodes = TRUE)
  
  # Extract data from the parsed GPX file
  coords <- xpathSApply(doc = gpx_parsed, path = "//trkpt", fun = xmlAttrs)
  elevation <- xpathSApply(doc = gpx_parsed, path = "//trkpt/ele", fun = xmlValue)
  time <- xpathSApply(doc = gpx_parsed, path = "//time", fun = xmlValue)
  name <- xpathSApply(doc = gpx_parsed, path = "//name", fun = xmlValue)
  
 
  # Generate new data frame with extracted values
  df <- data.frame(
    name = name,
    time = as.POSIXct(time[-1], format = "%Y-%m-%dT%H:%M:%OSZ"),
    lat = as.numeric(coords["lat", ]),
    lon = as.numeric(coords["lon", ]),
    elevation = as.numeric(elevation),
    messenger = as.factor(gsub(".*/gps_files_([^/]+)/.*", "\\1", file)),
 
     # Extract filenames and subfoldernames using gsub() credits go to:  https://stackoverflow.com/questions/54082781/extract-portion-of-file-name-using-gsub
  id = as.factor(paste(gsub('.*/(.*).gpx','\\1', file), gsub(".*/gps_files_([^/]+)/.*", "\\1", file), sep = "_"))
  )
  
  
  # transform into spatial data frame and project to new coordinate system
  df_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326, remove = FALSE)
  df_sf <- st_transform(df_sf, crs = 2056)
  df_sf$x <- st_coordinates(df_sf)[,1]
  df_sf$y <- st_coordinates(df_sf)[,2]
  df_sf <- select(df_sf, id, messenger, name, time, x, y, elevation, geometry)
  
 
  # Store every iterration into a singel data frame and send it to the list single_routes()
  single_routes[[file]] <- df_sf
  
  # Store every iterration into new rows of the existing data frame all_routes()
  all_routes <- rbind(all_routes, df_sf)
  
}

# Quick overview
tmap_mode("view")
tm_shape(single_routes$`gps_files_shared/gps_files_raeubertochter/F1.gpx`) +
  tm_dots( col = "messenger", palette = "seq", border.col = NULL)


```

# Task 2: Analysing sampling regime of all messengers

```{r}

all_routes_seg <- all_routes

#If a larger sampling grid is needed: selecting every 10th row from  movement data

#all_routes <- all_routes[seq(from = 1, to = #nrow(all_routes), by = 5), ]


all_routes_seg <- all_routes_seg |> # calculate rowwise time difference
    group_by(id) |> 
    mutate(
    time_difference = as.numeric(difftime(time, lag(time), units = "secs"))) |>
    ungroup()


# How do the time difference differ between days and messengers?

all_routes_seg |> 
  group_by(id) |> 
  summarise(
    mean <- mean(time_difference, na.rm = T)
    )

ggplot(all_routes_seg, aes(x = time_difference)) +
  geom_histogram(binwidth = 2) +
  scale_y_log10() +
  labs(x = "Time Difference", y = "Count (Log Scale)") +
  ggtitle("Histogram of Time Differences with Log Y Axis") +
  facet_wrap(all_routes_seg$id) +
  theme_minimal()


# Both with similar but slightly different sampling regimes, raeubertochter with an intervall of 1 second- It seems that static time is already removed..

# Donner with more variation between fixes, but still short intervalls, might need another segmentation...

# First we try the same segmentation for all messenegrs


all_routes_seg <- all_routes_seg |> 
   group_by(id) |> 
   mutate(
        nMinus2 = difftime(time, lag(time, 2)), 
        nMinus1 = difftime(time, lag(time,1)),  
        nPlus1  = difftime(lead(time, 1), time), 
        nPlus2  = difftime(lead(time, 2), time)  
    )


all_routes_seg <- all_routes_seg |> # calculate rowwise mean distance per messenger
    group_by(id) |> 
    rowwise() |>
    mutate(
        timeMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()


# create a new column static, based on time_difference (over 10s time difference)
all_routes_seg <- all_routes_seg |> 
  mutate(
    new_segment = timeMean > 10
  )

# it assigns unique IDs based on the column static
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

all_routes_seg <- all_routes_seg |>
    mutate(temp_id = rle_id(new_segment)) |> 
    filter(!new_segment)

# remove segments shorter than a minunte

all_routes_seg <- all_routes_seg |> 
  group_by(temp_id) |> 
  mutate(duration = difftime(max(time), min(time))
  ) |> 
  filter(!duration < 60) |> 
  ungroup()

# Adssing new segment_id starting at one, credits to: https://stackoverflow.com/questions/39650511/r-group-by-variable-and-then-assign-a-unique-id

all_routes_seg <- all_routes_seg |> 
  group_by(temp_id, messenger) |> 
  mutate(segment_id = as_factor(cur_group_id())) |> 
  ungroup() |> 
  select(-temp_id)

# visualize segments

ggplot(all_routes_seg,aes(x, y, color = segment_id)) +
    geom_path() +
    scale_fill_brewer(palette = "Set3") +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "none")+
    labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 60s removed") 


# It already looks really good????


all_routes_seg |> 
  group_by(messenger) |> 
  summarise(length(unique(segment_id)))


raeubertochter <- filter(all_routes_seg, messenger == "raeubertochter")

donner <- filter(all_routes_seg, messenger == "donner")


ggplot(donner,aes(x, y, color = segment_id)) +
    geom_path() +
    geom_point() +
    scale_fill_brewer(palette = "Set1") +
    coord_fixed() +
    theme(legend.position = "none")+
    labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 60s removed")  

ggplot(raeubertochter,aes(x, y, color = segment_id)) +
    geom_path() +
    geom_point() +
    scale_fill_brewer(palette = "Set1") +
    coord_fixed() +
    theme(legend.position = "none")+
    labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 60s removed")  


```

# Task 3: Start and Ending Points

```{r}


# Credits to: https://stackoverflow.com/questions/31528981/select-first-and-last-row-from-grouped-data


start_end <- all_routes_seg |> 
  group_by(segment_id) |> 
  filter(row_number()==1 | row_number()==n()) |> 
  mutate(
    position = rep(c("start", "end"), length.out = n()),
    point_type = paste()
  )

```

# Task 4: Import Spatial Data

```{r}

st_layers("basic_data.gpkg")

strassen <- read_sf("gis_files/basic_data.gpkg", "street_network") |> 
   select(objektart, geom) |> 
  mutate(
    objektart = as.factor(objektart),
    width = as.numeric(substr(objektart, start = 1, stop = 1))
  ) |> 
  filter(width > 1)
  

gebaeude <- read_sf("gis_files/basic_data.gpkg", "housing_footprint") |> 
   select(objektart, geom) |> 
  mutate(
    objektart = as.factor(objektart)
  )



p1 <- ggplot() +
  geom_sf(data = strassen, lwd = strassen$width/50, color = "lightgrey", fill = NA) +
  scale_linetype_identity() +
  geom_sf(data = all_routes, color = "yellow", size = 0.001) +
  theme_void() +
  theme(
    plot.background = element_rect(fill = "black"),
    panel.background = element_rect(fill = "black")
  )


png(file="day1.png", width = 125, height= 116.75, units= "mm", res=1000)
p1
dev.off() 




all_routes_lines <- all_routes |> 
  summarise(do_union = TRUE) |> 
  st_cast("LINESTRING")

plot(all_routes_lines)

ggplot() +
  geom_point(data = all_routes, aes(x, y), size = 0.01) +
  geom_path()+
  labs(y="y", x="x") +
  scale_x_continuous(limits = c(2678000, max(all_routes$x))) +
  scale_y_continuous(limits = c(1242000, max(all_routes$y))) +
  guides(y = "axis_truncated",
         x = "axis_truncated") +
  coord_fixed(clip = "off") +
   theme_classic() +
  theme(axis.title.y = element_text(size = 6, margin = margin(t = 0, r = 15, b = 0, l = 0)),
        axis.title.x = element_text(size = 6, margin = margin(t = 10, r = 0, b = 0, l = 0)),
        axis.line = element_line(size=0.3),
        axis.text.x = element_text(size = 6, margin = margin(t = 7.5, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(size = 6, margin = margin(t = 0, r = 7.5, b = 0, l = 0))) 



png(file="p2.png", width = 175, height= 175, units= "mm", res=1000)
p2
dev.off() 












ggplot() +
  geom_sf(data = strassen, lwd = strassen$width/50) +
  scale_linetype_identity() +
  geom_sf(data = gebaeude, alpha = 0.5) +
  scale_fill_manual("black") +
  theme_void()


ggplot() +
  geom_sf(data = gebaeude) +
  scale_fill_manual("darkgrey") +
  theme_void()


raeubertochter_map <- leaflet(all_routes) |> 
  addTiles() |> 
  addCircleMarkers(lng = ~x,
                   lat = ~y)

raeubertochter_map



```


