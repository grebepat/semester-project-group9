---
title: "preprocessing"
format: html
editor: visual
---

# Install Packages

```{r}
# install.packages("pacman")
library("pacman")
# 
# p_install("dplyr", force = FALSE)
# p_install("ggplot2", force = FALSE)
# p_install("readr", force = FALSE)
# p_install("tidyr", force = FALSE)
# p_install("sf", force = FALSE)
# p_install("terra", force = FALSE)
# p_install("tmap", force = FALSE)
# p_install("zoo", force = FALSE)
# p_install("units", force = FALSE)
# p_install("plotly", force = FALSE)
# p_install("patchwork", force = FALSE)
# p_install("tidyverse", force = FALSE)
# p_install("rjson", force = FALSE)
# p_install("jsonlite", force = FALSE)
# p_install("leaflet", force = TRUE)
# p_install("shiny", force = TRUE)
# p_install("XML", force = TRUE)
# p_install("lubridate", force = TRUE)
# p_install("ggh4x", force = TRUE)
# p_install("forcats", force = TRUE)
# p_install("purrr", force = TRUE)
# p_install("viridis", force = TRUE)
# p_install("osrm", force = TRUE)
# p_install("httr", force = TRUE)
# p_install("mapmatchr", force = TRUE)
# p_install("hereR", force = TRUE)
# p_install("geojson", force = FALSE)
# p_install("sp", force = TRUE)
<<<<<<< HEAD
# p_install("ggpubr", force = TRUE)
=======
 p_install("osmdata", force = FALSE)
>>>>>>> 5a73759a4c2dd810f6834186504c5297527ac21b
```


```{r}
library("ggh4x")
library("dplyr")
library("ggplot2")
library("tidyr")
library("sf")
library("sp")
library("terra")
library("tmap")
library("zoo")
library("units")
library("plotly")
library("patchwork")
library("tidyverse")
library("rjson")
library("jsonlite")
library("leaflet")
library("XML")
library("lubridate")
library("shiny")
library("forcats")
library("purrr")
library("viridis")
library("osrm")
library("httr")
library("mapmatchr")
library("geojsonsf")
library("here")
library("sp")
library("hereR")
<<<<<<< HEAD
library("ggpubr")
=======
library("osmdata")
>>>>>>> 5a73759a4c2dd810f6834186504c5297527ac21b

#>>>>>>> f08770080dcba2ba396927d0228eb68552f0b88e

```

# Task 1: Import Express: Bringing GPS Data Onboard

Folgend werden alle .gpx-Files aus dem Ordner *GPS_Daten* eingelesen. Aus den .gpx-Files werden die Koordinaten herausgelesen und jede gefahrene Route / Aktivität in einem neuen Dataframe abgespeichert. Die Dataframes landen alle in einer Liste `single_routes` und können über diese abgerufen und dargestellt werden. In einer weiteren Variante werden alle Daten in einen einzigen Data Frame verpackt `all_routes`.

```{r}
# generate a list of all filenames including the path from the subfolder they are stored in
file <- list.files("gps_files_shared", recursive = TRUE, pattern = "\\.gpx$", full.names = TRUE)

# Function to extract messenger and id from file path
extract_info <- function(file) {
  messenger <- as.factor(gsub(".*/gps_files_([^/]+)/.*", "\\1", file))
  id <- as.factor(paste(gsub('.*/(.*).gpx','\\1', file), gsub(".*/gps_files_([^/]+)/.*", "\\1", file), sep = "_"))
  list(messenger = messenger, id = id)
}

# Function to process each file
process_file <- function(file) {
  df <- st_read(file, "track_points")
  
  info <- extract_info(file)
  df$messenger <- info$messenger
  df$id <- info$id
  
  df_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326, remove = FALSE)
  df_sf <- st_transform(df_sf, crs = 2056)
  df_sf$shift <- gsub('.*/(.*).gpx','\\1', file)
  df_sf$x <- st_coordinates(df_sf)[,1]
  df_sf$y <- st_coordinates(df_sf)[,2]
  df_sf <- select(df_sf, id, messenger, shift, time, x, y, ele, geometry)
  
  df_sf$origin <- file
  df_sf
}

# Apply the function to each file using purrr's map function
single_routes <- purrr::map(file, process_file)

# Combine all results
all_routes <- do.call(rbind, single_routes)

raeubertochter_raw <- filter(all_routes, messenger == "raeubertochter")
donner_raw <- filter(all_routes, messenger == "donner")

# Quick overview
tmap_mode("plot")
tm_shape(single_routes[[2]]) +
  tm_dots(col = "messenger", palette = "seq", border.col = NULL)

```

# Task 2: Import Spatial Data

```{r}
st_layers("gis_files/basic_data.gpkg")

streets <- read_sf("gis_files/basic_data.gpkg", "street_network_z") |> 
   select(objektart, geom) |> 
  mutate(
    objektart = as.factor(objektart),
    width = as.numeric(substr(objektart, start = 1, stop = 1)),
    width_scaled = as.numeric(substr(objektart, start = 1, stop = 1)) *1000
  ) |> 
  na.omit()

streets <- streets %>%
  group_by(objektart) %>%
  summarize(geometry = st_union(geometry), .groups = "drop")

read_sf("")
  


housing <- read_sf("gis_files/basic_data.gpkg", "housing_footprint") |> 
   select(objektart, geom) |>
  mutate(
    objektart = as.factor(objektart)
  )


surface <- read_sf("gis_files/basic_data.gpkg", "surface_type") |> 
   select(art, geom) |> 
  mutate(
    art = as.factor(art)) |> 
 filter(art == "fliessendes Gewässer" | art == "stehendes Gewässer" | art == "Strasse, Weg" | art == "Verkehrsinsel") |> 
  na.omit()

summary(surface$art)


height <- terra::rast("gis_files/dhm25_zh.tif")

zurich <- st_bbox(c(xmin = 8.387726, ymin = 47.301000, xmax = 8.658916, ymax = 47.462420), crs = st_crs(4326))

# Convert bounding box to a polygon
zurich <- st_as_sfc(zurich)

# If you need to transform the CRS
zurich <- st_transform(zurich, crs = 2056)

# intersect the gis information files with the bounding box of zurich
housing <- st_intersection(housing, zurich)
streets <- st_intersection(streets, zurich)
surface <- st_intersection(surface, zurich)
```

# Task 3: Signal Sync: Assessing Sampling Intervals Across Messenger GPS Systems

```{r}

#If a larger sampling grid is needed: selecting every 10th row from  movement data
#all_routes <- all_routes[seq(from = 1, to = #nrow(all_routes), by = 5), ]

# calculate rowwise time difference
all_routes <- all_routes |> 
    group_by(id) |> 
    mutate(
    time_difference = as.numeric(difftime(time, lag(time), units = "secs"))) |>
    ungroup()


# How do the time difference differ between messengers?
all_routes |> 
  group_by(id) |> 
  filter(time_difference <= 30) |> # remove outliers to get a clearer view on the average sampling intervall
  summarise(
    mean <- mean(time_difference, na.rm = T)
    )

# max value between two fixes, in min
max(all_routes$time_difference, na.rm = T) / 60


p1 <- ggplot(all_routes, aes(x = time_difference)) +
  geom_histogram(binwidth = 2) +
  scale_y_log10() +
  labs(x = "Time Difference in sec.", y = "Count (Log Scale)") +
  ggtitle("Histogram of Time Differences with Log Y Axis") +
  facet_wrap(all_routes$id) +
  theme_minimal()

streets

p1


# Both with similar but slightly different sampling regimes, raeubertochter with an intervall of 1 second- It seems that static time is already removed..

# Donner with more variation between fixes, but still short intervals, might need another segmentation...

```

# Task 3: From Dots to Drops: Segmenting GPS Fixes into Deliveries

```{r}
# First we try the same segmentation method for all messengers

# create a moving time window
all_routes_seg <- all_routes |> 
   group_by(id) |> 
   mutate(
        nMinus2 = difftime(time, lag(time, 2)), 
        nMinus1 = difftime(time, lag(time,1)),  
        nPlus1  = difftime(lead(time, 1), time), 
        nPlus2  = difftime(lead(time, 2), time)  
    )

all_routes_seg <- all_routes_seg |> # calculate rowwise mean distance per messenger
    group_by(id) |>
    mutate(
        timeMean = (nMinus2 + nMinus1 + nPlus1 + nPlus2) / 4
    ) |>
    ungroup()



# all_routes_seg <- all_routes_seg |> # calculate rowwise mean distance per messenger
#     group_by(id) |> 
#     rowwise() |>
#     mutate(
#         timeMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
#     ) |>
#     ungroup()


# create a new column static, based on time_difference (over 20s time difference)
all_routes_seg <- all_routes_seg |> 
  mutate(new_segment = timeMean > 20)

# it assigns unique IDs based on the column static
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

# removes static rows
all_routes_seg <- all_routes_seg |>
    mutate(temp_id = rle_id(new_segment)) |> 
    filter(!new_segment)

# remove segments shorter than two minuntes
all_routes_seg <- all_routes_seg |> 
  group_by(temp_id) |> 
  mutate(duration = difftime(max(time), min(time))
  ) |> 
  filter(!duration < 120) |> 
  ungroup()

# Adssing new segment_id starting at one, credits to: https://stackoverflow.com/questions/39650511/r-group-by-variable-and-then-assign-a-unique-id
all_routes_seg <- all_routes_seg |> 
  group_by(temp_id, messenger) |> 
  mutate(segment_id = as_factor(cur_group_id())) |> 
  ungroup() |> 
  select(-temp_id)

# how many segments have been differentiated?
all_routes_seg |> 
  group_by(messenger) |> 
  summarise(length(unique(segment_id)))

# filter segments according to messenger
raeubertochter_seg <- filter(all_routes_seg, messenger == "raeubertochter")

donner_seg <- filter(all_routes_seg, messenger == "donner")

# visualize segments
# p2 <- ggplot(all_routes_seg,aes(x, y, color = segment_id)) +
#     scale_fill_brewer(palette = "Set3") +
#     geom_point() +
#     coord_fixed() +
#     theme_minimal() +
#     theme(legend.position = "none")+
#     labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 60s removed") 
# 
# p2

# visualize with tmap

tmap_mode("plot")

# visualize all trajectories
tm_shape(surface, bbox = all_routes_seg) +
  tm_polygons(border.col = NULL, col = "art", palette = my_palette, legend.show = F, ) +
tm_shape(housing, bbox = all_routes_seg) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(streets, bbox = all_routes_seg) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_layout(frame = FALSE) +
  tm_basemap(server = NULL) +
    tm_shape(all_routes_seg, bbox = all_routes_seg) +
    tm_dots(col = "segment_id", size = 0.1, palette = "viridis", legend.show = FALSE) +
  tmap_options(max.categories = 59)

# visualize donner only
tm_shape(surface, bbox = donner_seg) +
  tm_polygons(border.col = NULL, col = "art", palette = my_palette, legend.show = F, ) +
tm_shape(housing, bbox = donner_seg) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(streets, bbox = donner_seg) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_layout(frame = FALSE) +
  tm_basemap(server = NULL) +
    tm_shape(all_routes_seg, bbox = donner_seg) +
    tm_dots(col = "segment_id", size = 0.1, palette = "viridis", legend.show = FALSE) +
  tmap_options(max.categories = 59)

# visualize raeubertochter only
tm_shape(surface, bbox = raeubertochter_seg) +
  tm_polygons(border.col = NULL, col = "art", palette = my_palette, legend.show = F, ) +
tm_shape(housing, bbox = raeubertochter_seg) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(streets, bbox = raeubertochter_seg) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_layout(frame = FALSE) +
  tm_basemap(server = NULL) +
    tm_shape(all_routes_seg, bbox = raeubertochter_seg) +
    tm_dots(col = "segment_id", size = 0.1, palette = "viridis", legend.show = FALSE) +
  tmap_options(max.categories = 59)

# 
# p3 <- ggplot(donner_seg, aes(x, y, color = segment_id)) +
#     geom_path() +
#     geom_point() +
#     scale_fill_brewer(palette = "Set1") +
#     coord_fixed() +
#     theme(legend.position = "none")+
#     labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 120s removed")  
# 
# p4 <- ggplot(raeubertochter_seg, aes(x, y, color = segment_id)) +
#     geom_path() +
#     geom_point() +
#     scale_fill_brewer(palette = "Set1") +
#     coord_fixed() +
#     theme(legend.position = "none")+
#     labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 120s removed")  
# 

```

# Task 4: Lost in Transit: Tackling Tunnel GPS Blackouts for Bike Messenger

```{r}

all_routes_seg_tunnel <- all_routes_seg

first_last_points <- all_routes_seg_tunnel |> 
  group_by(segment_id) |> 
  slice(c(1, n())) |> 
  ungroup()

# Create a buffer around the tunnel entry and exit
tunnel_exit <- st_sfc(st_point(c(2682368, 1246996)), crs = 2056)
tunnel_entry <- st_sfc(st_point(c(2682592, 1246751)), crs = 2056)

# tunnel_points <- st_sfc(tunnel_entry, tunnel_exit, crs = 2056)
buffer_entry <- st_buffer(tunnel_entry, dist = 50)
buffer_exit <- st_buffer(tunnel_exit, dist = 50)


# Identify segments within the buffer
first_last_points_within <- first_last_points |> 
  mutate(
    intersect_start = sapply(st_intersects(geometry, buffer_entry, sparse = FALSE), any),
    intersect_end = sapply(st_intersects(geometry, buffer_exit, sparse = FALSE), any)
  ) |> 
  filter(intersect_start | intersect_end)

# Calculate time difference between end of one segment and start of the next
first_last_points_within <- first_last_points_within |> 
  arrange(segment_id, time) |> 
  mutate(time_diff = time - lag(time))

# Match segments where time difference is less than 2 minutes
matched_segments <- first_last_points_within |> 
  filter(time_diff <= 120 | is.na(time_diff) ) |> 
  mutate(new_segment_id = lag(segment_id)) |> 
  select(x,y,geometry,time_diff, segment_id, new_segment_id)

# create a table with matching segment starting / endpoints
lookup_table <- matched_segments |> 
  filter(!is.na(new_segment_id) & segment_id != new_segment_id) |> 
  select(segment_id, new_segment_id)  |> 
  distinct()

# Replace segment_id in all_routes_seg using lookup_vector, credits go to: https://stackoverflow.com/questions/35636315/replace-values-in-a-dataframe-based-on-lookup-table
lookup_vector <- setNames(lookup_table$new_segment_id, lookup_table$segment_id)

all_routes_seg_tunnel$segment_id_new <- ifelse(all_routes_seg_tunnel$segment_id %in% names(lookup_vector), 
                                    lookup_vector[match(all_routes_seg_tunnel$segment_id, names(lookup_vector))], 
                                    all_routes_seg_tunnel$segment_id)


all_routes_seg_tunnel_cor <- all_routes_seg_tunnel |> 
  group_by(segment_id_new, messenger) |> 
  mutate(segment_id_cor = as_factor(cur_group_id())) |> 
  select(-segment_id, -segment_id_new) |> 
  ungroup()


raeubertochter_cor <- filter(all_routes_seg_tunnel_cor, messenger == "raeubertochter")

donner_cor <- filter(all_routes_seg_tunnel_cor, messenger == "donner")


ggplot(donner_cor,aes(x, y, color = segment_id_cor)) +
    geom_path() +
    geom_point() +
    scale_fill_brewer(palette = "Set1") +
    coord_fixed() +
    theme(legend.position = "none")+
    labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 120s removed \nTunnel Challenge incl.")  

ggplot(raeubertochter_cor,aes(x, y, color = segment_id_cor)) +
    geom_path() +
    geom_point() +
    scale_fill_brewer(palette = "Set1") +
    coord_fixed() +
    theme(legend.position = "none")+
    labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 120s removed \nTunnel Challenge incl.")  
  

```

<<<<<<< HEAD
=======
# Task 4: Import Spatial Data

```{r}


st_layers("basic_data.gpkg")

streets <- read_sf("gis_files/basic_data.gpkg", "street_network", promote_to_multi = FALSE) |> 
   select(objektart, geom) |> 
  mutate(
    objektart = as.factor(objektart),
    width = as.numeric(substr(objektart, start = 1, stop = 1)),
    width_scaled = as.numeric(substr(objektart, start = 1, stop = 1)) *1000
  ) |> 
  na.omit()
  
?read_sf

streets <- streets %>%
  mutate(edgeID = c(1:n()))

streets <- st_zm(streets, drop = TRUE)

streets <- st_cast(streets, "LINESTRING")

plot(streets)

nodes <- streets %>%
  st_coordinates() %>%
  as_tibble() %>%
  rename(edgeID = L1) %>%
  group_by(edgeID) %>%
  slice(c(1, n())) %>%
  ungroup() %>%
  mutate(start_end = rep(c('start', 'end'), times = n()/2))

nodes <- nodes %>%
  mutate(xy = paste(.$X, .$Y)) %>% 
  mutate(nodeID = group_indices(., factor(xy, levels = unique(xy)))) %>%
  select(-xy)

nodes

source_nodes <- nodes %>%
  filter(start_end == 'start') %>%
  pull(nodeID)

target_nodes <- nodes %>%
  filter(start_end == 'end') %>%
  pull(nodeID)

streets = streets %>%
  mutate(from = source_nodes, to = target_nodes)

streets

tmap_mode("view")
tm_shape(streets) + 
  tm_lines() +
  tm_shape(nodes) +
  tm_dots()

nodes <- nodes %>%
  distinct(nodeID, .keep_all = TRUE) %>%
  select(-c(edgeID, start_end)) %>%
  st_as_sf(coords = c('X', 'Y')) %>%
  st_set_crs(st_crs(streets))


housing <- read_sf("gis_files/basic_data.gpkg", "housing_footprint") |> 
   select(objektart, geom) |> 
  mutate(
    objektart = as.factor(objektart)
  )


surface <- read_sf("gis_files/basic_data.gpkg", "surface_type") |> 
   select(art, geom) |> 
  mutate(
    art = as.factor(art)) |> 
 filter(art == "fliessendes Gewässer" | art == "stehendes Gewässer" | art == "Strasse, Weg" | art == "Verkehrsinsel") |> 
  na.omit()

summary(surface$art)


height <- terra::rast("gis_files/dhm25_zh.tif")

```

>>>>>>> 5a73759a4c2dd810f6834186504c5297527ac21b
# Alternative trajectories with hereR:route()

```{r}

a_to_b <- all_routes_seg_tunnel_cor |> 
  group_by(segment_id_cor) |> 
  slice(c(1, n())) |> 
  ungroup()

tmap_mode("plot")
tm_shape(a_to_b) + 
  tm_dots() 

library("hereR")
set_key("PARpVmlSSQAeuGjMhIdg94LMi9s1ha4UShazq0j8sAo")


# Create a dataframe with even rows
df_even <- a_to_b[seq(2, nrow(a_to_b), by = 2), ]
df_even <- df_even[1, ]


# Create a dataframe with odd rows
df_odd <- a_to_b[seq(1, nrow(a_to_b), by = 2), ]
df_odd <- df_odd[1,]

?route()

alternative <- route(origin = df_odd, destination = df_even, transport_mode = "bicycle", traffic = FALSE, results = 1 , routing_mode = "fast")
plot(alternative)


alternative <- st_transform(alternative, crs = 2056)

alternative <- st_cast(alternative, "POINT")
alternative <- st_zm(alternative, drop = TRUE)


donner_vis <- donner_cor |> 
  filter(segment_id_cor == 1)



extent2 <- st_transform(st_buffer(alternative, 200), crs = 2056)
st_bbox(extent2)

coords <- rbind(c(2679514  , 1249013 ), c(2683075, 1249013 ), c(2683075, 1247635), c(2679514 , 1247635), c(2679514 , 1249013 ))

# Create a polygon
polygon <- st_polygon(list(coords))

# Convert to spatial object
extent2 <- st_sfc(polygon, crs = 2056)


streets <- st_intersection(streets, extent2)
housing <- st_intersection(housing, extent2)

tmap_mode("view")
tm_shape(streets, bbox = extent2) +
  tm_lines(lwd = "width", scale = 1.5, legend.lwd.show = FALSE) +
tm_shape(alternative) +
  tm_lines(col = "rank", lwd = 2) +
tm_shape(df_even) +
  tm_dots(col = "lightblue", size = 2) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2) +
tm_shape(donner_vis) +
  tm_dots(col = "purple", size = .15) +
  tm_shape(pts) +
  tm_dots(col = "red") +
 tm_layout(frame = FALSE, bg.color = "transparent")


tm1 <- tm_shape(surface, bbox = extent2) +
  tm_polygons(border.col = NULL, col = "art", palette = my_palette, legend.show = F, ) +
tm_shape(housing, bbox = extent) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(streets, bbox = extent) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_layout(frame = FALSE) +
  tm_basemap(server = NULL)


tm10 <- tm_shape(streets, bbox = extent2) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing, bbox = extent2) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
  tm_layout(frame = FALSE)

tmap_save(tm10, "presentation/overview_routing.png", width =300, height = 150, dpi = 1000, units = "mm")


tm11 <- tm_shape(donner_vis, bbox = extent2) +
  tm_symbols(size = 0.5, col = "red",  alpha = 0.6, border.col = "NA") +
  tm_layout(frame = FALSE, bg.color = "transparent") 

tmap_save(tm11, "presentation/donner_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")


tm12 <-  tm_shape(df_even,  bbox = extent2) +
  tm_dots(col = "steelblue", size = 2.5, border.col = "NA", alpha = 0.9) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2.5, border.col = "NA", alpha = 0.9) +
  tm_layout(frame = FALSE, bg.color = "transparent") 

tmap_save(tm12, "presentation/start_end_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")


my_palette <- c("#11E2A1", "#9E1FA2")

tm13 <-  tm_shape(df_even,  bbox = extent2) +
  tm_dots(col = "steelblue", size = 2.5, border.col = "NA", alpha = 0.9) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2.5, border.col = "NA", alpha = 0.9) +
tm_shape(alternative) +
  tm_lines(col = "rank", lwd = 5, palette = my_palette, border.col = "NA", legend.col.show = F) +

  tm_layout(frame = FALSE, bg.color = "transparent") 

tmap_save(tm13, "presentation/alternative_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")



??hereR

tmap_mode("plot")
tm_shape(streets, bbox = donner_vis) +
  tm_lines(lwd = "width", scale = 1.5, legend.lwd.show = FALSE) +
tm_shape(alternative) +
  tm_lines(col = "rank", lwd = 2) +
tm_shape(df_even) +
  tm_dots(col = "lightblue", size = 2) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2) +
tm_shape(donner_vis) +
  tm_dots(col = "purple", size = .15) 

```


## Map Matching

```{r}

library(sf)
library(tmap)

################################### Nils #######################################################

# Define the coordinates of the polygon
coords <- rbind(c(2681695, 1247822), c(2683188, 1247822), c(2683188, 1246616), c(2681695, 1246616), c(2681695, 1247822))

# Create a polygon
polygon <- st_polygon(list(coords))

# Convert to spatial object
extent <- st_sfc(polygon, crs = 2056)


# since we want to find the closest location on the road over ALL roads
# we need to create a union of the roads first.
street_network <- st_union(streets)

?st_nearest_points

# Let's assume 'gps_locations' are your existing points
# gps_locations <- ...

# Now we can get the nearest point for each GPS location
nearest_route <- st_nearest_points(all_routes_seg_tunnel_cor, street_network)
nearest_alternative <- st_nearest_points(alternative, street_network)

# The output is a line for each point
# Now we need convert the output from LINE to POINT. 
# This doubles the number of features
near_p_route <- st_cast(nearest_route, "POINT")
near_p_alternative <- st_cast(nearest_alternative, "POINT")

# now we subset the points. Even numbers are the new, mapmatched points.
near_to_route <- near_p_route[c(FALSE,TRUE)]
near_to_alternative <- near_p_alternative[c(FALSE,TRUE)]

# Update the geometry of the original points with the new locations
st_geometry(all_routes_seg_tunnel_cor) <- st_geometry(near_to_route)
st_geometry(alternative) <- st_geometry(near_to_alternative)


tmap_mode("view")


tm_shape(street_network) + 
  tm_lines() +
tm_shape(nearest_route) + 
  tm_lines(lty = 3) +
tm_shape(all_routes_seg_tunnel_cor$geometry) + 
  tm_dots(col = "purple") + 
tm_shape(near_to_route) + 
  tm_dots(col = "lightblue")


tm_shape(street_network) + 
  tm_lines() +
tm_shape(nearest_alternative) + 
  tm_lines(lty = 3) +
tm_shape(alternative$geometry) + 
  tm_dots(col = "purple") 



```


# Combinig actual and alternative routes

```{r}



```


# Enrich street network

```{r}
# Enrich dataset for actual route
traj <- all_routes_seg_tunnel_cor |> 
  select(id, messenger, shift, time, geometry, duration, segment_id_cor)

#tm_shape(all_routes_seg_tunnel_cor) +
 # tm_dots()  +
  #tm_shape(streets) +
  #tm_lines()

traj2 <- st_buffer(traj, 0.25)

traj_width <- st_join(traj2, streets, left = TRUE, suffix = "street", join = st_intersects)


traj_count <- traj_width |> 
  st_drop_geometry() |> 
  group_by(messenger, segment_id_cor, width) |> 
  summarise(count = n()) |> 
  mutate(total = sum(count), 
         percentage = count / total * 100) |> 
ungroup()


head(traj_width)

traj_width <-  st_centroid(traj_width, crs = 2056)



plot(height)

extracted_height <- extract(height, traj_width)

traj_width$height <- round(extracted_height$dhm25_zh,2)

slope <- terrain(height, v = "slope", unit = "degrees", neighbors = 8)
extracted_slope <- extract(slope, traj_width)
traj_width$slope <- round(extracted_slope$slope,2)

traj_enriched <- traj_width |> 
  select(-width_scaled, -objektart)





traj_enriched_final <- traj_enriched %>%
  st_transform(crs = 2056) |> 
  arrange(segment_id_cor) %>%
  group_by(segment_id_cor) %>%
  mutate(height_diff = c(0, diff(height)),
         height_cumulative_up = cumsum(ifelse(height_diff > 0, height_diff, 0)),
         height_cumulative_down = cumsum(ifelse(height_diff < 0, height_diff, 0)),
         height_tot_up = sum(ifelse(height_diff > 0, height_diff, 0), na.rm = T),
         height_tot_down = sum(ifelse(height_diff < 0, height_diff, 0), na.rm = T),
         lead_geom = lead(geometry),
         travel_dist = sqrt(round(ifelse(!is.na(lead_geom), st_distance(lead_geom, geometry, by_element = TRUE), 0), 1))^2,
         slope_calc = ifelse(travel_dist != 0, atan(height_diff / travel_dist), 0), 
         slope_cumulative_up = cumsum(ifelse(slope_calc > 0, slope_calc, 0)),
         slope_cumultaive_down = cumsum(ifelse(slope_calc < 0, slope_calc, 0)),
         slope_tot_up = sum(ifelse(slope_calc > 0, slope_calc, 0), na.rm = T),
         slope_tot_down = sum(ifelse(slope_calc < 0, slope_calc, 0), na.rm = T),
         travel_dist_tot = sum(ifelse(travel_dist > 0, travel_dist, 0), na.rm = T),
         n_fixes = n()) |> 
  ungroup()


width_preference <- traj_enriched_final %>%
  group_by(messenger, segment_id_cor, width) %>%
  summarise(
    sum = sum(travel_dist, na.rm = T)
  ) |> 
  group_by(messenger) |> 
  mutate(
    width = as.factor(width),
    tot = sum(sum),
    perc = (sum / tot) * 100,
    pref = perc - 16.67
  )





# enrich dataset for alternatives


# Enrich dataset for actual route
alt <- alternative |> 
  select(id, rank,  geometry)

#tm_shape(all_routes_seg_tunnel_cor) +
 # tm_dots()  +
  #tm_shape(streets) +
  #tm_lines()

alt2 <- st_buffer(alt, 0.25)

alt_width <- st_join(alt2, streets, left = TRUE, suffix = "street", join = st_intersects)


alt_count <- alt_width |> 
  st_drop_geometry() |> 
  group_by(id, width) |> 
  summarise(count = n()) |> 
  mutate(total = sum(count), 
         percentage = count / total * 100) |> 
ungroup()


head(traj_width)

alt_width <-  st_centroid(alt_width, crs = 2056)



plot(height)

extracted_height_alt <- extract(height, alt_width)

alt_width$height <- round(extracted_height_alt$dhm25_zh,2)

slope_alt <- terrain(height, v = "slope", unit = "degrees", neighbors = 8)
extracted_slope_alt <- extract(slope_alt, alt_width)
alt_width$slope <- round(extracted_slope_alt$slope,2)

alt_enriched <- alt_width |> 
  select(-width_scaled, -objektart)





alt_enriched_final <- alt_enriched %>%
  st_transform(crs = 2056) |> 
  arrange(id) %>%
  group_by(id) %>%
  mutate(height_diff = c(0, diff(height)),
         height_cumulative_up = cumsum(ifelse(height_diff > 0, height_diff, 0)),
         height_cumulative_down = cumsum(ifelse(height_diff < 0, height_diff, 0)),
         height_tot_up = sum(ifelse(height_diff > 0, height_diff, 0), na.rm = T),
         height_tot_down = sum(ifelse(height_diff < 0, height_diff, 0), na.rm = T),
         lead_geom = lead(geometry),
         travel_dist = sqrt(round(ifelse(!is.na(lead_geom), st_distance(lead_geom, geometry, by_element = TRUE), 0), 1))^2,
         slope_calc = ifelse(travel_dist != 0, atan(height_diff / travel_dist), 0), 
         slope_cumulative_up = cumsum(ifelse(slope_calc > 0, slope_calc, 0)),
         slope_cumultaive_down = cumsum(ifelse(slope_calc < 0, slope_calc, 0)),
         slope_tot_up = sum(ifelse(slope_calc > 0, slope_calc, 0), na.rm = T),
         slope_tot_down = sum(ifelse(slope_calc < 0, slope_calc, 0), na.rm = T),
         travel_dist_tot = sum(ifelse(travel_dist > 0, travel_dist, 0), na.rm = T),
         n_fixes = n()) |> 
  ungroup()


width_preference_alt <- alt_enriched_final %>%
  group_by(id, width) %>%
  summarise(
    sum = sum(travel_dist, na.rm = T)
  ) |> 
  group_by(id) |> 
  mutate(
    width = as.factor(width),
    tot = sum(sum),
    perc = (sum / tot) * 100,
    pref = perc - 16.67
  )
ungroup()
summarise(pref)












ggplot(width_preference) +
  geom_boxplot(aes(x = width, y = perc, fill = messenger))


ggplot(width_preference_alt) +
  geom_boxplot(aes(x = width, y = perc))


ggplot(width_preference_alt, aes(x= pref , y= width, group = width )) +
  geom_bar(stat = "identity", position = position_dodge2(0.9, padding = 0), width = 0.6) 

  
  scale_pattern_manual(values = c("1931-2011" = "none", "2011-2023" = "stripe", "1931-2023" = "none")) +
  labs(y="Art", x="Höhenverschiebung [m]") +
  guides(x = guide_axis_truncated(trunc_lower = -150, trunc_upper = 600),
         y = "axis_truncated", 
        fill = guide_legend(label.position = "bottom")) +
   theme_classic() +
  theme(axis.title.y = element_text(size = 6, margin = margin(t = 0, r = 15, b = 0, l = 0)),
        axis.title.x = element_text(size = 6, margin = margin(t = 10, r = 0, b = 0, l = 0)),
        axis.line = element_line(size=0.3),
        axis.ticks.y = element_line(size=0.3),
        axis.ticks.x = element_line(size=0.6),
        axis.text.x = element_text(size = 6, margin = margin(t = 7.5, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(face = "italic", size = 6, margin = margin(t = 0, r = 7.5, b = 0, l = 0)),
        legend.position = "bottom",
        legend.text = element_text(size = 6),
        legend.key.width = unit(0.3, 'cm'),
        legend.key.height = unit(0.2, 'cm'),
        legend.key.spacing.x = unit(0.5, 'cm'),
        legend.title = element_blank()
        )



 subset_taj <- taj_enriched %>%
  filter(segment_id_cor %in% sample(unique(segment_id_cor), 5)) # Adjust the number of segments as needed

# Apply the same operations but print out the intermediate results
subset_taj <- subset_taj %>%
  st_transform(crs = 2056) %>%
  arrange(segment_id_cor) %>%
  group_by(segment_id_cor) %>%
  mutate(
    lag_geom = lag(geometry),
    travel_dist = st_distance(lag_geom, geometry)
  ) 

# Print out the results
head(subset_taj)




euclid <- function(x1, x2, y1, y2){
  distance <- sqrt((x2 - x1)^2 + (y2 - y1)^2)
  return(distance)
}




taj_mahal |> 
  filter(segment_id_cor == 1 | segment_id_cor == 2) |> 
 ggplot( aes(x = time, y = travel_dist, color = segment_id_cor)) +
  geom_line() +
  scale_fill_brewer(palette = "Set1")  # Use a color palette that suits your data

```

# Alternative trajectories with hereR:route()

```{r}

a_to_b <- traj_enriched_final |> 
  group_by(segment_id_cor) |> 
  slice(c(1, n())) |> 
  ungroup()

tmap_mode("plot")
tm_shape(a_to_b) + 
  tm_dots() 

library("hereR")
set_key("PARpVmlSSQAeuGjMhIdg94LMi9s1ha4UShazq0j8sAo")


# Create a dataframe with even rows
df_even <- a_to_b[seq(2, nrow(a_to_b), by = 2), ]
df_even <- df_even[1, ]


# Create a dataframe with odd rows
df_odd <- a_to_b[seq(1, nrow(a_to_b), by = 2), ]
df_odd <- df_odd[1,]

?route()

alternative <- route(origin = df_odd, destination = df_even, transport_mode = "bicycle", traffic = FALSE, results = 1 , routing_mode = "fast")
plot(alternative)




donner_vis <- donner_cor |> 
  filter(segment_id_cor == 1)



extent2 <- st_transform(st_buffer(alternative, 200), crs = 2056)
st_bbox(extent2)

coords <- rbind(c(2679514  , 1249013 ), c(2683075, 1249013 ), c(2683075, 1247635), c(2679514 , 1247635), c(2679514 , 1249013 ))

# Create a polygon
polygon <- st_polygon(list(coords))

# Convert to spatial object
extent2 <- st_sfc(polygon, crs = 2056)

pts <- st_cast(alternative, "POINT")

streets <- st_intersection(streets, extent2)
housing <- st_intersection(housing, extent2)

tmap_mode("view")
tm_shape(streets, bbox = extent2) +
  tm_lines(lwd = "width", scale = 1.5, legend.lwd.show = FALSE) +
tm_shape(alternative) +
  tm_lines(col = "rank", lwd = 2) +
tm_shape(df_even) +
  tm_dots(col = "lightblue", size = 2) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2) +
tm_shape(donner_vis) +
  tm_dots(col = "purple", size = .15) +
  tm_shape(pts) +
  tm_dots(col = "red") +
 tm_layout(frame = FALSE, bg.color = "transparent")


tm1 <- tm_shape(surface, bbox = extent2) +
  tm_polygons(border.col = NULL, col = "art", palette = my_palette, legend.show = F, ) +
tm_shape(housing, bbox = extent) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(streets, bbox = extent) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_layout(frame = FALSE) +
  tm_basemap(server = NULL)


tm10 <- tm_shape(streets, bbox = extent2) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing, bbox = extent2) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
  tm_layout(frame = FALSE)

tmap_save(tm10, "presentation/overview_routing.png", width =300, height = 150, dpi = 1000, units = "mm")


tm11 <- tm_shape(donner_vis, bbox = extent2) +
  tm_symbols(size = 0.5, col = "red",  alpha = 0.6, border.col = "NA") +
  tm_layout(frame = FALSE, bg.color = "transparent") 

tmap_save(tm11, "presentation/donner_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")


tm12 <-  tm_shape(df_even,  bbox = extent2) +
  tm_dots(col = "steelblue", size = 2.5, border.col = "NA", alpha = 0.9) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2.5, border.col = "NA", alpha = 0.9) +
  tm_layout(frame = FALSE, bg.color = "transparent") 

tmap_save(tm12, "presentation/start_end_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")


my_palette <- c("#11E2A1", "#9E1FA2")

tm13 <-  tm_shape(df_even,  bbox = extent2) +
  tm_dots(col = "steelblue", size = 2.5, border.col = "NA", alpha = 0.9) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2.5, border.col = "NA", alpha = 0.9) +
tm_shape(alternative) +
  tm_lines(col = "rank", lwd = 5, palette = my_palette, border.col = "NA", legend.col.show = F) +

  tm_layout(frame = FALSE, bg.color = "transparent") 

tmap_save(tm13, "presentation/alternative_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")



??hereR

tmap_mode("plot")
tm_shape(streets, bbox = donner_vis) +
  tm_lines(lwd = "width", scale = 1.5, legend.lwd.show = FALSE) +
tm_shape(alternative) +
  tm_lines(col = "rank", lwd = 2) +
tm_shape(df_even) +
  tm_dots(col = "lightblue", size = 2) +
tm_shape(df_odd) +
  tm_dots(col = "gold", size = 2) +
tm_shape(donner_vis) +
  tm_dots(col = "purple", size = .15) 

```

# Challenges

1.  Loosing all information using spatial tools like st_cast, interpolating etc... we loose our information stored in different columns and only get back a point geometry...

2.  Comparing time differences between pairs of last/first segment points in tunnel buffer...

3.  Map matching only on roads that we care about

4.  Do we work with points, line segments, nodes? How do we summarize for example slope on a given road?
