---
title: "preprocessing"
format: html
editor: visual
---

# Install Packages

```{r}
install.packages("pacman")
library("pacman")


p_install("dplyr", force = FALSE)
p_install("ggplot2", force = FALSE)
p_install("readr", force = FALSE)
p_install("tidyr", force = FALSE)
p_install("sf", force = FALSE)
p_install("terra", force = FALSE)
p_install("tmap", force = FALSE)
p_install("zoo", force = FALSE)
p_install("units", force = FALSE)
p_install("plotly", force = FALSE)
p_install("patchwork", force = FALSE)
p_install("tidyverse", force = FALSE)
p_install("rjson", force = FALSE)
p_install("jsonlite", force = FALSE)
p_install("leaflet", force = FALSE)
p_install("shiny", force = FALSE)
p_install("XML", force = FALSE)
p_install("lubridate", force = FALSE)
p_install("ggh4x", force = FALSE)
p_install("forcats", force = FALSE)
p_install("purrr", force = FALSE)
p_install("viridis", force = FALSE)
p_install("osrm", force = FALSE)
p_install("httr", force = FALSE)
p_install("hereR", force = FALSE)
p_install("geojson", force = FALSE)
p_install("sp", force = FALSE)
p_install("osmdata", force = FALSE)
p_install("ggpubr", force = TRUE)
p_install("gganimate", force = FALSE)
p_install("magick", force = FALSE)
p_install("gifski", force = FALSE)
p_install("png", force = FALSE)
p_install("grid", force = FALSE)
p_install("raster", force = FALSE)

library("ggh4x")
library("dplyr")
library("ggplot2")
library("tidyr")
library("sf")
library("sp")
library("terra")
library("tmap")
library("zoo")
library("units")
library("plotly")
library("patchwork")
library("tidyverse")
library("rjson")
library("jsonlite")
library("leaflet")
library("XML")
library("lubridate")
library("shiny")
library("forcats")
library("purrr")
library("viridis")
library("osrm")
library("httr")
library("geojsonsf")
library("here")
library("sp")
library("hereR")
library("osmdata")
library("gganimate")
library("magick")
library("gifski")
library("png")
library("grid")



```

# Task 1: Import Express: Bringing GPS Data Onboard

Folgend werden alle .gpx-Files aus dem Ordner *GPS_Daten* eingelesen. Aus den .gpx-Files werden die Koordinaten herausgelesen und jede gefahrene Route / Aktivität in einem neuen Dataframe abgespeichert. Die Dataframes landen alle in einer Liste `single_routes` und können über diese abgerufen und dargestellt werden. In einer weiteren Variante werden alle Daten in einen einzigen Data Frame verpackt `all_routes`.

```{r}

# generate a list of all filenames including the path from the subfolder they are stored in
file <- list.files("gps_files_shared", recursive = TRUE, pattern = "\\.gpx$", full.names = TRUE)

# Function to extract messenger and id from file path
extract_info <- function(file) {
  messenger <- as.factor(gsub(".*/gps_files_([^/]+)/.*", "\\1", file))
  id <- as.factor(paste(gsub('.*/(.*).gpx','\\1', file), gsub(".*/gps_files_([^/]+)/.*", "\\1", file), sep = "_"))
  list(messenger = messenger, id = id)
}

# Function to process each file
process_file <- function(file) {
  df <- st_read(file, "track_points")
  
  info <- extract_info(file)
  df$messenger <- info$messenger
  df$id <- info$id
  
  df_sf <- st_as_sf(df, coords = c("lon", "lat"), crs = 4326, remove = FALSE)
  df_sf <- st_transform(df_sf, crs = 2056)
  df_sf$shift <- gsub('.*/(.*).gpx','\\1', file)
  df_sf$x <- st_coordinates(df_sf)[,1]
  df_sf$y <- st_coordinates(df_sf)[,2]
  df_sf <- select(df_sf, id, messenger, shift, time, x, y, ele, geometry)
  
  df_sf$origin <- file
  df_sf
}

# Apply the function to each file using purrr's map function
single_routes <- purrr::map(file, process_file)

# Combine all results
all_routes <- do.call(rbind, single_routes)

raeubertochter_raw <- filter(all_routes, messenger == "raeubertochter")
donner_raw <- filter(all_routes, messenger == "donner")


# If filtering certain rides is needed
# filter only messenger rides. We do this by filtering the routes that have taken place in the city of zurich

# # Define simple bounding box for Zurich
# zurich <- st_bbox(c(xmin = 8.387726, ymin = 47.301000, xmax = 8.658916, ymax = 47.462420), crs = st_crs(4326))
# 
# # Convert the bounding box to a polygon
# zurich <- st_as_sfc(zurich)
# 
# # Transform the CRS of zurich to match that of donner_raw
# zurich <- st_transform(zurich, st_crs(donner_raw))
# 
# tm_shape(zurich) +
#   tm_polygons()
# 
# # Filter the points within the Zurich bounding box
# donner_filtered <- donner_raw[st_intersects(donner_raw, zurich, sparse = FALSE), ]
# 
# tmap_mode("view")
# 
# tm_shape(donner_filtered) +
#   tm_dots()
# 
# all_routes2 <- donner_filtered %>% 
#   bind_rows(raeubertochter_raw)


# Quick overview
tmap_mode("plot")
tm_shape(all_routes) +
  tm_dots(col = "messenger", palette = "seq", border.col = NULL)

```

# Task 2: Import Spatial Data

```{r}

st_layers("gis_files/basic_data.gpkg")

streets <- read_sf("gis_files/basic_data.gpkg", "street_network_z") |> 
   select(objektart, geom) |> 
  mutate(
    objektart = as.factor(objektart),
    width = as.numeric(substr(objektart, start = 1, stop = 1)),
  ) |> 
  na.omit()

# 
# streets <- streets %>%
#   group_by(objektart) %>%
#   summarize(geometry = st_union(geometry), .groups = "drop")
# 

  
outline <- read_sf("gis_files/basic_data.gpkg", "city_outline")

housing <- read_sf("gis_files/basic_data.gpkg", "housing_footprint") |> 
   select(objektart, geom) |>
  mutate(
    objektart = as.factor(objektart)
  )

housing_union <- st_union(housing)
housing_simpl <- st_simplify(housing_union, dTolerance = 0.001)


surface <- read_sf("gis_files/basic_data.gpkg", "surface_type") |> 
   select(art, geom) |> 
  mutate(
    art = as.factor(art)) |> 
 filter(art == "fliessendes Gewässer" | art == "stehendes Gewässer" | art == "Strasse, Weg" | art == "Verkehrsinsel") |> 
  na.omit()


height <- terra::rast("gis_files/dhm25_zh.tif")

# zurich <- st_bbox(c(xmin = 8.387726, ymin = 47.301000, xmax = 8.658916, ymax = 47.462420), crs = st_crs(4326))
# 
# # Convert bounding box to a polygon
# zurich <- st_as_sfc(zurich)
# 
# # If you need to transform the CRS
# zurich <- st_transform(zurich, crs = 2056)
# 
# # intersect the gis information files with the bounding box of zurich
# housing <- st_intersection(housing, zurich)
# streets <- st_intersection(streets, zurich)
# surface <- st_intersection(surface, zurich)

# Extent Raeubertochter
coords <- rbind(c(2678862, 1246191), c(2684134, 1246191), c(2684134, 1249710), c(2678862, 1249710), c(2678862, 1246191))

# Create a polygon
polygon <- st_polygon(list(coords))

# Convert to spatial object
extent_raeubertochter <- st_sfc(polygon, crs = 2056)


housing_raeubertochter <- st_intersection(housing, extent_raeubertochter)
streets_raeubertochter <- st_intersection(streets, extent_raeubertochter)
surface_raeubertochter <- st_intersection(surface, extent_raeubertochter)



tm1 <- tm_shape(streets_raeubertochter, bbox = extent_raeubertochter) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing_raeubertochter, bbox = extent_raeubertochter) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(raeubertochter_raw, bbox = extent_raeubertochter) +
  tm_symbols(size = 0.6, col = "red",  alpha = 0.7, border.col = "NA") +
  tm_layout(frame = FALSE) 

tmap_save(tm1, "raeubertochter_raw.png", width = 800, height = 600, dpi = 800, units = "mm")


box2 <- st_bbox(donner_raw)

tm3 <- tm_shape(streets, bbox = box2) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing, bbox = box2) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(donner_raw, bbox = box2) +
  tm_symbols(size = 0.6, col = "red",  alpha = 0.7, border.col = "NA") +
  tm_layout(frame = FALSE) 

tmap_save(tm3, "raeubertochter_raw.png", width = 800, height = 600, dpi = 800, units = "mm")


```

# Task 3: Signal Sync: Assessing Sampling Intervals Across Messenger GPS Systems

```{r}

#If a larger sampling grid is needed: selecting every 10th row from  movement data
#all_routes <- all_routes[seq(from = 1, to = #nrow(all_routes), by = 5), ]

# calculate rowwise time difference
all_routes <- all_routes |> 
    group_by(id) |> 
    mutate(
    time_difference = as.numeric(difftime(time, lag(time), units = "secs"))) |>
    ungroup()


# How do the time difference differ between messengers?
all_routes |> 
  group_by(id) |> 
  filter(time_difference <= 30) |> # remove outliers to get a clearer view on the average sampling intervall
  summarise(
    mean <- mean(time_difference, na.rm = T)
    )

# max value between two fixes, in min
max(all_routes$time_difference, na.rm = T) / 60


ggplot(all_routes, aes(x = time_difference)) +
  geom_histogram(binwidth = 2) +
  scale_y_log10() +
  labs(x = "Time Difference in sec.", y = "Count (Log Scale)") +
  ggtitle("Histogram of Time Differences with Log Y Axis") +
  facet_wrap(all_routes$id) +
  theme_minimal()



# Both with similar but slightly different sampling regimes, raeubertochter with an intervall of 1 second- It seems that static time is already removed..

# Donner with more variation between fixes, but still short intervals, might need another segmentation...


```

# Task 4: From Dots to Drops: Segmenting GPS Fixes into Deliveries

```{r}

# First we try the same segmentation method for all messengers

# create a moving time window
all_routes_seg <- all_routes |> 
   group_by(id) |> 
   mutate(
        nMinus2 = difftime(time, lag(time, 2)), 
        nMinus1 = difftime(time, lag(time,1)),  
        nPlus1  = difftime(lead(time, 1), time), 
        nPlus2  = difftime(lead(time, 2), time)  
    )

all_routes_seg <- all_routes_seg |> # calculate rowwise mean distance per messenger
    group_by(id) |>
    mutate(
        timeMean = (nMinus2 + nMinus1 + nPlus1 + nPlus2) / 4
    ) |>
    ungroup()



# all_routes_seg <- all_routes_seg |> # calculate rowwise mean distance per messenger
#     group_by(id) |> 
#     rowwise() |>
#     mutate(
#         timeMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
#     ) |>
#     ungroup()


# create a new column static, based on time_difference (over 20s time difference)
all_routes_seg <- all_routes_seg |> 
  mutate(new_segment = timeMean > 20)

# it assigns unique IDs based on the column static
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

# removes static rows
all_routes_seg <- all_routes_seg |>
    mutate(temp_id = rle_id(new_segment)) |> 
    filter(!new_segment)

# remove segments shorter than two minuntes
all_routes_seg <- all_routes_seg |> 
  group_by(temp_id) |> 
  mutate(duration = difftime(max(time), min(time))
  ) |> 
  filter(!duration < 120) |> 
  ungroup()

# Adssing new segment_id starting at one, credits to: https://stackoverflow.com/questions/39650511/r-group-by-variable-and-then-assign-a-unique-id
all_routes_seg <- all_routes_seg |> 
  group_by(temp_id, messenger) |> 
  mutate(segment_id = as_factor(cur_group_id())) |> 
  ungroup() |> 
  select(-temp_id)

# how many segments have been differentiated?
all_routes_seg |> 
  group_by(messenger) |> 
  summarise(length(unique(segment_id)))

# filter segments according to messenger
raeubertochter_seg <- filter(all_routes_seg, messenger == "raeubertochter")
donner_seg <- filter(all_routes_seg, messenger == "donner")


box3 <- st_bbox(raeubertochter_seg)

tm3 <- tm_shape(streets, bbox = box3) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing, bbox = box3) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(raeubertochter_seg, bbox = box3) +
  tm_symbols(size = 0.6, col = "red",  alpha = 0.7, border.col = "NA") +
  tm_layout(frame = FALSE) 

tmap_save(tm3, "raeubertochter_seg.png", width = 250, height = 200, dpi = 1000, units = "mm")


box4 <- st_bbox(donner_seg)

tm4 <- tm_shape(streets, bbox = box4) +
  tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
tm_shape(housing, bbox = box4) +
  tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
tm_shape(donner_seg, bbox = box4) +
  tm_symbols(size = 0.6, col = "red",  alpha = 0.7, border.col = "NA") +
  tm_layout(frame = FALSE) 

tmap_save(tm4, "donner_seg.png", width = 250, height = 200, dpi = 1000, units = "mm")

```

# Task 5: Lost in Transit: Tackling Tunnel GPS Blackouts for Bike Messenger

```{r}

all_routes_seg_tunnel <- all_routes_seg

first_last_points <- all_routes_seg_tunnel |> 
  group_by(segment_id) |> 
  slice(c(1, n())) |> 
  ungroup()

# Create a buffer around the tunnel entry and exit, for future project, there migth be a dataset with tunnel entities, where we could extract the entry and exit points automatically
tunnel_exit <- st_sfc(st_point(c(2682368, 1246996)), crs = 2056)
tunnel_entry <- st_sfc(st_point(c(2682592, 1246751)), crs = 2056)

# tunnel_points <- st_sfc(tunnel_entry, tunnel_exit, crs = 2056)
buffer_entry <- st_buffer(tunnel_entry, dist = 50)
buffer_exit <- st_buffer(tunnel_exit, dist = 50)


# Identify segments within the buffer
first_last_points_within <- first_last_points |> 
  mutate(
    intersect_start = sapply(st_intersects(geometry, buffer_entry, sparse = FALSE), any),
    intersect_end = sapply(st_intersects(geometry, buffer_exit, sparse = FALSE), any)
  ) |> 
  filter(intersect_start | intersect_end)

# Calculate time difference between end of one segment and start of the next
first_last_points_within <- first_last_points_within |> 
  arrange(segment_id, time) |> 
  mutate(time_diff = time - lag(time))

# Match segments where time difference is less than 2 minutes
matched_segments <- first_last_points_within |> 
  filter(time_diff <= 120 | is.na(time_diff) ) |> 
  mutate(new_segment_id = lag(segment_id)) |> 
  select(x,y,geometry,time_diff, segment_id, new_segment_id)

# create a table with matching segment starting / endpoints
lookup_table <- matched_segments |> 
  filter(!is.na(new_segment_id) & segment_id != new_segment_id) |> 
  select(segment_id, new_segment_id)  |> 
  distinct()

# Replace segment_id in all_routes_seg using lookup_vector, credits go to: https://stackoverflow.com/questions/35636315/replace-values-in-a-dataframe-based-on-lookup-table
lookup_vector <- setNames(lookup_table$new_segment_id, lookup_table$segment_id)

all_routes_seg_tunnel$segment_id_new <- ifelse(all_routes_seg_tunnel$segment_id %in% names(lookup_vector), lookup_vector[match(all_routes_seg_tunnel$segment_id, names(lookup_vector))], all_routes_seg_tunnel$segment_id)


all_routes_seg_tunnel_cor <- all_routes_seg_tunnel |> 
  group_by(segment_id_new, messenger) |> 
  mutate(segment_id_cor = as_factor(cur_group_id())) |> 
  select(-segment_id, -segment_id_new) |> 
  ungroup()


raeubertochter_cor <- filter(all_routes_seg_tunnel_cor, messenger == "raeubertochter")

donner_cor <- filter(all_routes_seg_tunnel_cor, messenger == "donner")

# 
# ggplot(donner_cor,aes(x, y, color = segment_id_cor)) +
#     geom_path() +
#     geom_point() +
#     scale_fill_brewer(palette = "Set1") +
#     coord_fixed() +
#     theme(legend.position = "none")+
#     labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 120s removed \nTunnel Challenge incl.")  
# 
# ggplot(raeubertochter_cor,aes(x, y, color = segment_id_cor)) +
#     geom_path() +
#     geom_point() +
#     scale_fill_brewer(palette = "Set1") +
#     coord_fixed() +
#     theme(legend.position = "none")+
#     labs(title = "Deliveries", subtitle="Segmentation set at time_difference > 10s \nSegments < 120s removed \nTunnel Challenge incl.")  
  

```

# Task 6: Creating alternative trajectories with hereR:route()

```{r}

# Extract starting and endpoints from real world trajecotries
a_to_b <- all_routes_seg_tunnel_cor |> 
  group_by(segment_id_cor) |> 
  slice(c(1, n())) |> 
  ungroup()

# quick and dirty overview
tmap_mode("plot")
tm_shape(a_to_b) + 
  tm_dots(col = "gold", size = .25) 

# Get accsess to API from here
library("hereR")
set_key("PARpVmlSSQAeuGjMhIdg94LMi9s1ha4UShazq0j8sAo")


# Create a dataframe with even rows
df_even <- a_to_b[seq(2, nrow(a_to_b), by = 2), ]

# if a single smaple is needed
# df_even <- df_even[1, ]


# Create a dataframe with odd rows
df_odd <- a_to_b[seq(1, nrow(a_to_b), by = 2), ]




# if a single smaple is needed
#df_odd <- df_odd[1,]

# create an alternative route for every single segment

alternative <- route(origin = df_odd, destination = df_even, transport_mode = "bicycle", traffic = FALSE, results = 1 , routing_mode = "fast")

alternative <- alternative |> 
  st_transform(crs = 2056) |> 
  st_cast("POINT") |> 
  st_zm(drop = TRUE) |> 
  rename(segment_id = id)


# Visualisation for the presentation
# extent2 <- st_transform(st_buffer(alternative, 200), crs = 2056)
# st_bbox(extent2)
# 
# coords <- rbind(c(2679514  , 1249013 ), c(2683075, 1249013 ), c(2683075, 1247635), c(2679514 , 1247635), c(2679514 , 1249013 ))
# 
# # Create a polygon
# polygon <- st_polygon(list(coords))
# 
# # Convert to spatial object
# extent2 <- st_sfc(polygon, crs = 2056)
# 
# 
# streets <- st_intersection(streets, extent2)
# housing <- st_intersection(housing, extent2)


alternative <- st_transform(alternative, crs = 2056)

alternative <- st_cast(alternative, "POINT")
alternative <- st_zm(alternative, drop = TRUE)


# donner_vis <- donner_cor |> 
#   filter(segment_id_cor == 1)
# 
# 
# 
# extent2 <- st_transform(st_buffer(alternative, 200), crs = 2056)
# st_bbox(extent2)
# 
# coords <- rbind(c(2679514  , 1249013 ), c(2683075, 1249013 ), c(2683075, 1247635), c(2679514 , 1247635), c(2679514 , 1249013 ))
# 
# # Create a polygon
# polygon <- st_polygon(list(coords))
# 
# # Convert to spatial object
# extent2 <- st_sfc(polygon, crs = 2056)
# 
# 
# streets <- st_intersection(streets, extent2)
# housing <- st_intersection(housing, extent2)

####>>>>>>> c50551c116e76f6ae0ae8710ecfdb9c816aea5c3
# tmap_mode("view")
# tm_shape(streets, bbox = extent2) +
#   tm_lines(lwd = "width", scale = 1.5, legend.lwd.show = FALSE) +
# tm_shape(alternative) +
#   tm_lines(col = "rank", lwd = 2) +
# tm_shape(df_even) +
#   tm_dots(col = "lightblue", size = 2) +
# tm_shape(df_odd) +
#   tm_dots(col = "gold", size = 2) +
# tm_shape(donner_vis) +
#   tm_dots(col = "purple", size = .15) +
#   tm_shape(pts) +
#   tm_dots(col = "red") +
#  tm_layout(frame = FALSE, bg.color = "transparent")
# 
# 
# tm1 <- tm_shape(surface, bbox = extent2) +
#   tm_polygons(border.col = NULL, col = "art", palette = my_palette, legend.show = F, ) +
# tm_shape(housing, bbox = extent) +
#   tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
# tm_shape(streets, bbox = extent) +
#   tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
# tm_layout(frame = FALSE) +
#   tm_basemap(server = NULL)
# 
# 
# tm10 <- tm_shape(streets, bbox = extent2) +
#   tm_lines(lwd = "width", scale = 2.5, legend.lwd.show = FALSE) +
# tm_shape(housing, bbox = extent2) +
#   tm_polygons(col = "grey25", border.col = "white", lwd = 0.5, alpha = .9) +
#   tm_layout(frame = FALSE)
# 
# tmap_save(tm10, "presentation/overview_routing.png", width =300, height = 150, dpi = 1000, units = "mm")
# 
# 
# tm11 <- tm_shape(donner_vis, bbox = extent2) +
#   tm_symbols(size = 0.5, col = "red",  alpha = 0.6, border.col = "NA") +
#   tm_layout(frame = FALSE, bg.color = "transparent") 
# 
# tmap_save(tm11, "presentation/donner_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")
# 
# 
# tm12 <-  tm_shape(df_even,  bbox = extent2) +
#   tm_dots(col = "steelblue", size = 2.5, border.col = "NA", alpha = 0.9) +
# tm_shape(df_odd) +
#   tm_dots(col = "gold", size = 2.5, border.col = "NA", alpha = 0.9) +
#   tm_layout(frame = FALSE, bg.color = "transparent") 
# 
# tmap_save(tm12, "presentation/start_end_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")
# 
# 
# my_palette <- c("#11E2A1", "#9E1FA2")
# 
# tm13 <-  tm_shape(df_even,  bbox = extent2) +
#   tm_dots(col = "steelblue", size = 2.5, border.col = "NA", alpha = 0.9) +
# tm_shape(df_odd) +
#   tm_dots(col = "gold", size = 2.5, border.col = "NA", alpha = 0.9) +
# tm_shape(alternative) +
#   tm_lines(col = "rank", lwd = 5, palette = my_palette, border.col = "NA", legend.col.show = F) +
# 
#   tm_layout(frame = FALSE, bg.color = "transparent") 
# 
# tmap_save(tm13, "presentation/alternative_routing.png", width =300, height = 150, dpi = 1000, units = "mm", bg="transparent")
# 
# 
# 
# ??hereR
# 
# tmap_mode("plot")
# tm_shape(streets, bbox = donner_vis) +
#   tm_lines(lwd = "width", scale = 1.5, legend.lwd.show = FALSE) +
# tm_shape(alternative) +
#   tm_lines(col = "rank", lwd = 2) +
# tm_shape(df_even) +
#   tm_dots(col = "lightblue", size = 2) +
# tm_shape(df_odd) +
#   tm_dots(col = "gold", size = 2) +
# tm_shape(donner_vis) +
#   tm_dots(col = "purple", size = .15) 


```

# Task 7: Combining Trajectories and Alternatives into a singel Data Frame

```{r}

# simplify original dataframe
original <- all_routes_seg_tunnel_cor |> 
  select(messenger, time, geometry, segment_id_cor) |> 
  rename(segment_id = segment_id_cor) |> 
  mutate(
    type = as.character("original"),
    segment_id = as.numeric(segment_id)
    )


false <- traj_enriched_final |> 
  filter(segment_id == 57 & type == "original" & travel_dist < 2) 

traj_enriched_final |> 
  filter(segment_id == 57 & type == "original") |> 
tm_shape() +
  tm_dots(col = "travel_dist") +
tm_shape(false) +
tm_dots(col = "gold", size = 0.05)



  
# simplify alternative datast
alternative <- alternative |> 
  select(segment_id, geometry) |> 
  st_transform(crs = 2056) |> 
  mutate(
    type = as.character("alternative"),
    segment_id = as.numeric(segment_id)
    
  )

#combine the dataset
combined <- bind_rows(original, alternative)

# fill in missing messenger values
combined <- combined |> 
  arrange(segment_id, messenger) |> 
  fill(messenger, .direction = "down")




```

# Task 8: Map Matching

```{r}

library(sf)
library(tmap)

# Map matching provided by Nils

# I a smaller sampling / visualization is needed
# Define the coordinates of the polygon
# coords <- rbind(c(2681695, 1247822), c(2683188, 1247822), c(2683188, 1246616), c(2681695, 1246616), c(2681695, 1247822))
# 
# # Create a polygon
# polygon <- st_polygon(list(coords))
# 
# # Convert to spatial object
# extent <- st_sfc(polygon, crs = 2056)


# since we want to find the closest location on the road over ALL roads
# we need to create a union of the roads first.
street_network <- st_union(streets)


# Let's assume 'gps_locations' are your existing points
# gps_locations <- ...

# Now we can get the nearest point for each GPS location
nearest <- st_nearest_points(combined, street_network)


# The output is a line for each point
# Now we need convert the output from LINE to POINT. 
# This doubles the number of features
near_p <- st_cast(nearest, "POINT")


# now we subset the points. Even numbers are the new, mapmatched points.
near_to <- near_p[c(FALSE,TRUE)]


# Update the geometry of the original points with the new locations
st_geometry(combined) <- st_geometry(near_to)



tmap_mode("view")



tm_shape(street_network) + 
  tm_lines() +
tm_shape(nearest) + 
  tm_lines(lty = 3) +
tm_shape(combined) + 
  tm_dots(col = "messenger") + 
tm_shape(near_to) + 
  tm_dots(col = "lightblue")

# tm_shape(street_network) + 
#   tm_lines() +
# tm_shape(nearest_route) + 
#   tm_lines(lty = 3) +
# tm_shape(all_routes_seg_tunnel_cor$geometry) + 
#   tm_dots(col = "purple") + 
# tm_shape(near_to_route) + 
#   tm_dots(col = "lightblue")
# 
# 
# tm_shape(street_network) + 
#   tm_lines() +
# tm_shape(nearest_alternative) + 
#   tm_lines(lty = 3) +
# tm_shape(alternative$geometry) + 
#   tm_dots(col = "purple") 


```

# Task 9: Interpolating Data Frame

```{r}

combined <- select(combined, -time)

df_lines <- combined %>%
  group_by(type, messenger, segment_id) %>%
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("LINESTRING")

df_merged <- combined %>%
  group_by(type, messenger, segment_id) %>%
  summarise(geometry = st_union(geometry), do_union = FALSE) %>%
  st_cast("LINESTRING")
##### interpolating


# Assuming 'df' is your spatial dataframe
# And 'segment_id' is the column that separates different line segments

# Function to interpolate points along lines
interpolate_points <- function(geometry, dist=10) {
  len <- st_length(geometry)
  n_points <- ceiling(len / dist)
  st_line_sample(geometry, sample = seq(0, 1, length.out = n_points))
}



?ceiling

# Apply the function to each LINESTRING
df_lines$points <- purrr::map(df_lines$geometry, interpolate_points)



# Unnest the points
df_points <- tidyr::unnest(df_lines, points)



# byebye LINEGEOMETRY
df_points <- df_points |> 
  st_drop_geometry(geometry)

df_points$x = df_points$points[, 1]
df_points$y = df_points$points[, 2]
  
  

# HELLO POINTGEOMETRY
df_sf <- st_as_sf(df_points, coords = c("x", "y"))
df_sf <- st_as_sf(df_points)



# Use st_cast to convert multipoint to single point
df_single_points <- st_cast(df_sf, "POINT")

df_single_points <- st_set_crs(df_single_points, 2056)
df_single_points <- st_transform(df_single_points, crs = 2056)

df_single_points

tmap_mode("view")
df_single_points |> 
  filter(segment_id == 57) |> 

tm_shape() +
  tm_dots(col = "red")



```

# Task 9: Enrich network

```{r}
# Enrich combined dataset with street and environmental data

traj <- st_buffer(df_single_points, 0.5)

traj <- st_set_crs(traj, 2056)

traj_width <- st_join(traj, streets, left = TRUE, suffix = "street", join = st_intersects)

traj_width <-  st_centroid(traj_width, crs = 2056)


traj_width <- traj_width |> 
  arrange(type, messenger, segment_id) |> 
  fill(objektart, .direction = "down") |> 
  fill(width, .direction = "down")



# traj_count <- traj_width |> 
#   st_drop_geometry() |> 
#   group_by(messenger, segment_id, width) |> 
#   summarise(count = n()) |> 
#   mutate(total = sum(count), 
#          percentage = count / total * 100) |> 
# ungroup()


# Extract height at every point
extracted_height <- extract(height, traj_width)
traj_width$height <- round(extracted_height$dhm25_zh,2)




# Extract slope at every point
slope <- terrain(height, v = "slope", unit = "degrees", neighbors = 8)
extracted_slope <- extract(slope, traj_width)
traj_width$slope <- round(extracted_slope$slope,2)

# simplify dataframe
traj_enriched <- traj_width |> 
  select(-objektart, -points)

str(traj_enriched)
# Calculations between a pair of points

traj_enriched_final <- traj_enriched |> 
  arrange(type, segment_id) |> 
  group_by(type, segment_id) |> 
  mutate(lead_geom = lead(points),
         travel_dist = sqrt(round(ifelse(!is.na(lead_geom), st_distance(lead_geom, points, by_element = TRUE), 0), 1))^2,
         dist_cumulative = cumsum(ifelse(travel_dist > 0, travel_dist, 0)), 
         tot_segment_length = max(dist_cumulative, na.rm = T),
         height_diff = c(0, diff(height)),
         tot_height_up = sum(ifelse(height_diff > 0, height_diff, 0)),
         tot_height_down = sum(ifelse(height_diff < 0, height_diff, 0)),
         slope_calc = ifelse(travel_dist != 0, (height_diff / travel_dist)*100, 0)
         ) 
  na.omit()


# Analysing result
  
false <- traj_enriched_final |> 
  filter(segment_id == 4 & type == "original", travel_dist < 4.01)
blabla <- traj_enriched_final |> 
  filter(segment_id == 4 & type == "original", travel_dist > 5) 
haha <- df_lines |> 
  filter(segment_id == 4 & type == "original")
  
tm_shape(false) +
tm_dots(col = "gold", size = 0.15)+
tm_shape(blabla) +
  tm_dots(col = "travel_dist") +
  tm_shape(haha) +
  tm_lines()



# somehow the interpolation did not work as expected, there are some overlaying points resulting in a travel_dist of 0.. also euclid distance results in travel_dist shorter than 10m because of turning angles..


# Cleaning

traj_cleaned <- traj_enriched_final |> 
  filter(!travel_dist < 4.5) 

  
# repeat calculations

new <- traj_cleaned |> 
  arrange(type, segment_id) |> 
  group_by(type, segment_id) |> 
  mutate(lead_geom = lead(points),
         travel_dist = sqrt(round(ifelse(!is.na(lead_geom), st_distance(lead_geom, points, by_element = TRUE), 0), 1))^2,
         dist_cumulative = cumsum(ifelse(travel_dist > 0, travel_dist, 0)), 
         tot_segment_length = max(dist_cumulative, na.rm = T),
         height_diff = c(0, diff(height)),
         tot_height_up = sum(ifelse(height_diff > 0, height_diff, 0)),
         tot_height_down = sum(ifelse(height_diff < 0, height_diff, 0)),
         slope_calc = ifelse(travel_dist != 0, (height_diff / travel_dist)*100, 0)
         ) |> 
  na.omit()


# setting travel distance to 10m manually, travelled distance was 10m on the line, so euclidiean distance is a little usless

new$travel_dist = 10

  
# Calculation over 100m travel distance
# Indexing 100m segments
  
  

  
new <- new |> 
group_by(type, messenger, segment_id) |> 
mutate(
    index = as.integer(cumsum(travel_dist) / 100.1 + 1)
 )


new <- new |> 
  mutate(
    type = as.factor(type),
    segment_id = as.factor(segment_id),
    index = as.factor(index),
    width = as.factor(width)
  )

new <- new |> 
group_by(type, messenger, segment_id, index) |> 
mutate(
   height_diff_100 = last(height) - first(height),
   n = n()
    )
 

str(new)
    
alternative <- new |> 
      filter(type == "alternative")
    
    
original_final <- traj_enriched_final |> 
      filter(type == "original")
    
    





    
  #   mean_slope_100 = dative = cumsum(ifelse(travel_dist > 0, travel_dist, 0)), 
  #        max_slope_100 = 
  #        height_diff = c(0, diff(height)),
  #        slope_calc = ifelse(travel_dist != 0, atan(height_diff / travel_dist), 0)
  #        ) 
  # na.omit()








# ###### might not needed again
# 
# traj_simple <- traj_enriched_final |> 
#   group_by(type, messenger, segment_id, index) |> 
#   slice(c(1, n())) |> 
#   ungroup()
# 
# traj_simple <- traj_simple |> 
#   group_by(type, segment_id) |> 
#   mutate(lead_geom = lead(geometry))
# 

  


# calculate several parameters to enrich trajectrorie, such as slope between two fixes, distance, height difference etc.
# traj_enriched_final <- traj_enriched_final |> 
#   arrange(type, messenger, segment_id, index) |> 
#   group_by(type, messenger, segment_id, index) |> 
#   mutate(height_diff = c(0, diff(height)),
#          slope_calc = ifelse(travel_dist != 0, atan(height_diff100 / travel_dist), 0)
#          )|> 
#   ungroup()
# 
# 
# 
# traj_simple <- traj_simple |>
#   arrange(type, messenger, segment_id,) |>
#   group_by(type, messenger, segment_id) |>
#   mutate(
#     height_cumulative_up = cumsum(ifelse(height_diff100 > 0, height_diff100, 0)),
#     height_cumulative_down = cumsum(ifelse(height_diff100 < 0, height_diff100, 0)),
#     slope_cumulative_up = cumsum(ifelse(slope_calc > 0, slope_calc, 0)),
#     slope_cumultaive_down = cumsum(ifelse(slope_calc < 0, slope_calc, 0)),
#     sum_heigt_up = max(height_cumulative_up, na.rm = T),
#     sum_heigt_down = min(height_cumulative_down, na.rm = T),
#     sum_slope_up = max(slope_cumulative_up, na.rm = T),
#     sum_slope_down = min(slope_cumultaive_down, na.rm = T)
#     
#     
#     )|>
#   ungroup()




  # slope_up100 = ifelse(slope_calc > 0, slope_calc, 0), na.rm = T,
  #        slope_down100 = ifelse(slope_calc < 0, slope_calc, 0), na.rm = T
 # height_up100 = cumsum(ifelse(height_diff100 > 0, height_diff100, 0), na.rm = T),
 #         height_down100 = cumsum(ifelse(height_diff100 < 0, height_diff100, 0), na.rm = T),

         # height_diff = c(0, diff(height)),
         # height_cumulative_up = cumsum(ifelse(height_diff > 0, height_diff, 0)),
         # height_cumulative_down = cumsum(ifelse(height_diff < 0, height_diff, 0)),
         # height_up = mean(ifelse(height_diff > 0, height_diff, 0), na.rm = T),
         # height_down = mean(ifelse(height_diff < 0, height_diff, 0), na.rm = T),
         # slope_calc = ifelse(travel_dist != 0, atan(height_diff / travel_dist), 0),
         # slope_cumulative_up = cumsum(ifelse(slope_calc > 0, slope_calc, 0)),
         # slope_cumultaive_down = cumsum(ifelse(slope_calc < 0, slope_calc, 0)),
         # slope_tot_up = sum(ifelse(slope_calc > 0, slope_calc, 0), na.rm = T),
         # slope_tot_down = sum(ifelse(slope_calc < 0, slope_calc, 0), na.rm = T),
         # travel_dist_tot = sum(ifelse(travel_dist > 0, travel_dist, 0), na.rm = T),
         # n_fixes = n())


# 
# 
# 

# 
# donner <- filter(traj_enriched_final, messenger == "donner")
# raeubertocher <- filter(traj_enriched_final, messenger == "raeubertochter")
# 

# 
# traj_enriched_final$new_slope <- NA # Create a new column for slopes every 50m
# 
# for(i in 1:nrow(traj_enriched_final)) {
#   if(traj_enriched_final$dist_cumulative[i] >= 100) {
#     # Calculate slope as (change in height / change in distance)
#     traj_enriched_final$new_slope[i] <- (traj_enriched_final$height_diff[i] / traj_enriched_final$travel_dist[i]) * 100
#     # Reset counter after calculating slope
#     traj_enriched_final$travel_dist[i] <- traj_enriched_final$travel_dist[i] - 100
#   }
# }
# 


```

# Task 10: Results

|                           |       | original |       |       | alternative |       |       |
|----------------------|---------|:--------|:--------|:--------|:--------|:--------|:--------|
| variable                  | unit  | min      | mean  | max   | min         | mean  | max   |
| travel distance           | \[m\] | 584      | 2226  | 4039  | 360         | 2305  | 4089  |
| average gradient per 100m | \[%\] | -8.88    | 0.04  | 11.8  | -11.7       | -0.01  | 9.72  |
| max. gradient per 100m    | \[%\] | 0        | 4.14  | 75.0 | 0           | 3.37  | 64.7  |
| height up                 | \[m\] | 0.68     | 20.5  | 87.7  | 0.78        | 17.2  | 83.1  |
| height down               | \[m\] | -0.25    | -20.2 | -89.3 | -0.39       | -18.4 | -61.9 |

```{r}

# Descriptive analysis
new |> 
  st_drop_geometry() |> 
  group_by(type) |> 
  summarise(Mittelwert = mean(tot_segment_length), Minimum = min(tot_segment_length), Maximum = max(tot_segment_length)
            , Standardabweichung = sd(tot_segment_length), Bereich = (max(tot_segment_length)-min(tot_segment_length)), median(tot_segment_length))

    

new |> 
  st_drop_geometry() |> 
  group_by(type) |> 
  summarise(Mittelwert = mean(tot_height_up), Minimum = min(tot_height_up), Maximum = max(tot_height_up)
            , Standardabweichung = sd(tot_height_up), Bereich = (max(tot_height_up)-min(tot_height_up)), median(tot_height_up))




new |> 
  st_drop_geometry() |> 
  group_by(type) |> 
  summarise(Mittelwert = mean(tot_height_down), Minimum = min(tot_height_down), Maximum = max(tot_height_down)
            , Standardabweichung = sd(tot_height_down), Bereich = (max(tot_height_down)-min(tot_height_down)), median(tot_height_down))




# Werte auf 100m Teilstücke zusammengefasst

results <- new %>%
  group_by(type, segment_id, index) %>%
  na.omit() |> 
  summarise(
    n = n(),
     slope_down = mean(ifelse(slope_calc < 0, slope_calc, 0), na.rm = TRUE),
     slope_up = mean(ifelse(slope_calc > 0, slope_calc, 0), na.rm = TRUE),
     max_slope = max((slope_calc), na.rm = TRUE),
    min_slope = min((slope_calc),na.rm = TRUE),
    mean_slope = mean((slope_calc), na.rm = TRUE),
     mean_slope100 = mean((height_diff_100 / (n*10))) *100
     # Mean of 'value' column per group
  )

results |> 
  st_drop_geometry() |> 
  group_by(type) |> 
  summarise(meanMittelwert = mean(mean_slope100), meanMinimum = min(mean_slope100), meanMaximum = max(mean_slope100),
            meanMax100 = mean(max_slope),
            maxMax100 = max(max_slope), 
            minMin = min(max_slope))




# Comparison of length
length_comp <- new |> 
  select(type, messenger, segment_id,  tot_segment_length)


df_spread <- length_comp %>%
  spread(key = type, value = tot_segment_length)

# Compare 'tot_travel' for "original" and "alternative"
df_spread <- df_spread %>%
  mutate(is_original_shorter = original < alternative)



df_spread <- tidyr::spread(length_comp, type, tot_segment_length)

df_spread <- length_comp |> 
  group_by(type, segment_id) |> 
  summarise(
    tot_travel = mean(tot_segment_length)
  )

comparison <- df_spread %>%
  group_by(segment_id) %>%
  summarise(shorter = min(tot_travel[type == "original"]) < min(tot_travel[type == "alternative"]))

shorter_count <- sum(comparison$shorter)

# Calculate the total number of unique 'segment_id's
total_segments <- nrow(comparison)

# Calculate the percentage
percentage <- (shorter_count / total_segments) * 100

## original routes were shorter than shortest alternative in 60% of the times

orig = df_spread |> 
  st_drop_geometry() |> 
  filter(type == "original")

alt = df_spread |> 
  st_drop_geometry() |> 
  filter(type == "alternative")

common_segments <- inner_join(orig, alt, by = "segment_id")

t.test(common_segments$tot_travel.x, common_segments$tot_travel.y, paired = TRUE)

# Unterschiede aber nicht signifikant








 boxplot(traj_enriched_final$tot_slope_up_100)   
    
    
    
 ggplot(new) +
   geom_boxplot(aes(type, tot_segment_length))
 
 
    
    
ggplot(results, aes(x = max_slope)) +
  geom_histogram(binwidth = 1) +
  labs(x = "Time Difference in sec.", y = "Count)") +
  ggtitle("Histogram of Time Differences with Log Y Axis") +
  facet_wrap(~type) +
  theme_minimal()
    



# 
width_preference <- new %>%
  group_by(type, messenger, segment_id, width) %>%
  summarise(
    sum = sum(travel_dist, na.rm = T)
  ) |>
  group_by(type, segment_id) |>
  mutate(
    width = as.factor(width),
    n = n(),
    tot = sum(sum),
    perc = (sum / tot) * 100,
    sum_tot = sum(perc),
    pref = perc - (100/n)
  )

width_preference$width <- factor(width_preference$width, levels = sort(as.numeric(levels(width_preference$width))))

ggplot(width_preference) +
  geom_boxplot(aes(x = width, y = pref, fill = type))


?geom_bar
ggplot(width_preference) +
  geom_bar(aes(x = width, y = pref, fill = type), stat = "identity", position = "dodge") +
  coord_flip() +
  theme_minimal() +
  labs(x = "Width", y = "Preference", fill = "Type")


```

# Restlicher Chabis

```{r}
# alle restlich shizzle

# Ansatz 1 scheisse

gps_points <- st_buffer(all_routes_seg_tunnel_cor, 0.25)
on_the_road <- st_join(gps_points, streets, left = TRUE, suffix = "street", join = st_intersects)
on_the_road <- st_drop_geometry(on_the_road)
on_the_road <- left_join(on_the_road, streets, by = "edgeID")
on_the_road <- st_as_sf(on_the_road)


# Ansatz 2 noch blöder
gps_points <- st_buffer(all_routes_seg_tunnel_cor, 0.25)
on_the_road <- st_join(gps_points, streets, left = TRUE, suffix = "street", join = st_intersects)
on_the_road <-  st_centroid(on_the_road, crs = 2056)
on_the_road <- st_cast(on_the_road, "LINESTRING")


on_the_road2 <- st_cast(on_the_road, "POINT")

on_the_road2 <- st_intersection(gps_points, streets)
traj_width <-  st_centroid(traj_width, crs = 2056)
gps_points <- st_join(all_routes_seg_tunnel_cor, streets)

tm_shape(on_the_road2) +
  tm_dots() +
tm_shape(on_the_road) +
  tm_lines(col = "segment_id_cor")
  

tm_shape(pts) +
  tm_dots() +
tm_shape(alternative) +
  tm_lines(col = "id")



# 
# 
# traj_enriched_final <- traj_enriched |> 
#   arrange(type, segment_id) |> 
#   group_by(type, segment_id) |> 
#   mutate(lead_geom = lead(points),
#          travel_dist = sqrt(round(ifelse(!is.na(lead_geom), st_distance(lead_geom, points, by_element = TRUE), 0), 1))^2,
#          dist_cumulative = cumsum(ifelse(travel_dist > 0, travel_dist, 0)), 
#          tot_segment_length = max(dist_cumulative, na.rm = T),
#          height_diff = c(0, diff(height)),
#          tot_height_up = sum(ifelse(height_diff > 0, height_diff, 0)),
#          tot_height_down = sum(ifelse(height_diff < 0, height_diff, 0)),
#          slope_calc = ifelse(travel_dist != 0, (height_diff / travel_dist)*100, 0),
#          tot_slope_up = sum(ifelse(slope_calc > 0, slope_calc, 0), na.rm = T),
#          tot_slope_down = sum(ifelse(slope_calc < 0, slope_calc, 0), na.rm = T)
#          ) 
#   na.omit()
# 
# 
# 
# 
#   
# # Calculation over 100m travel distance
# # Indexing 100m segments
#   
# traj_enriched_final <- traj_enriched_final |> 
# group_by(type, messenger, segment_id) |> 
# mutate(
#     index = as.integer(cumsum(travel_dist) / 100.1 + 1)
#  )
# 
# 
# 
# traj_enriched_final <- traj_enriched_final |> 
#   arrange(type, messenger, segment_id, index) |> 
#   group_by(type, messenger, segment_id, index) |> 
#   mutate(
#     tot_up_100 = sum(ifelse(height_diff > 0, height_diff, 0)),
#     mean_up_100 = mean(ifelse(height_diff > 0, height_diff, 0)),
#     max_up_100 = max(ifelse(height_diff > 0, height_diff, 0)),
#     tot_down_100 = sum(ifelse(height_diff < 0, height_diff, 0)),
#     mean_down_100 = mean(ifelse(height_diff < 0, height_diff, 0)),
#     max_down_100 = min(ifelse(height_diff < 0, height_diff, 0)),
#     tot_slope_up_100 = sum(ifelse(slope_calc > 0, slope_calc, 0), na.rm = T),
#     mean_slope_up_100 = mean(ifelse(slope_calc > 0, slope_calc, 0), na.rm = T),
#     max_slope_up_100 = max(ifelse(slope_calc > 0, slope_calc, 0)),
#     tot_slope_down_100 = sum(ifelse(slope_calc < 0, slope_calc, 0)),
#     mean_slope_down_100 = mean(ifelse(slope_calc < 0, slope_calc, 0)),
#     max_slope_down_100 = min(ifelse(slope_calc < 0, slope_calc, 0)),
#     )
#   
# traj_enriched_final <- traj_enriched_final |> 
#   mutate(
#     type = as.factor(type),
#     segment_id = as.factor(segment_id),
#     index = as.factor(index),
#     width = as.factor(width)
#   )
# 
# 
# str(traj_enriched_final)
#     
# alternative_final <- traj_enriched_final |> 
#       filter(type == "alternative")
#     
#     
# original_final <- traj_enriched_final |> 
#       filter(type == "original")

```

# Challenges / what to do next time

1.  Loosing all information using spatial tools like st_cast, interpolating etc... we loose our information stored in different columns and only get back a point geometry...

2.  Comparing time differences between pairs of last/first segment points in tunnel buffer...

3.  Map matching only on roads that we care about

4.  Do we work with points, line segments, nodes? How do we summarize for example slope on a given road?

5.  Interpolating original and alternative routes so we get points every 10 m or so. irregular / regular sampling regime
